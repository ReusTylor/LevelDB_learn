## 节点结构体：
### 成员
- key ：节点的键值，存储节点的关键字
- next_：一个长度为节点高度的原子指针数组，用于存储节点在不同层级上的后继节点。
  
### 方法：
- `Next(int n)`：根据给定的层级 n，返回指向下一个节点的指针。
使用原子操作和获取内存语义，从数组 next_ 中读取指定层级 n 的后继节点的指针，并返回该指针值。这样可以保证在多线程环境下，获取到的后继节点指针是其他线程最新的版本，确保了数据的一致性和正确性。
- `SetNext(int n, Node* x)`:将给定层级 n 上的后继指针设置为节点 x。使用了原子操作store，将x写入到next_数组的索引n处。使用原子操作和释放内存语义，将节点在给定层级 n 的后继指针设置为节点 x。这样可以保证在多线程环境下，其他线程读取到的后继指针是被完全初始化的插入节点 x，确保了数据的一致性和正确性。
通过C++中的内存序来实现

### newnode 方法
创建跳表节点，并返回节点指针。
`arena_->AllocateAligned(...)`调用arena_对象的AllocateAligned方法，用于分配一块内存，以容纳新节点的数据和指针数组。完成节点的创建过程。
使用定位new的方式：好处在于：定位 new 的好处是可以在已经分配的内存上构造对象，适用于某些场景，例如在固定的内存区域或内存池中分配对象、在特定的内存对齐要求下分配对象等。它可以提高性能、避免不必要的内存分配，并允许更灵活地管理对象的内存。

### 迭代器的一些方法